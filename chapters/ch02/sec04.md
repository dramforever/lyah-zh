## 2.4 范围

(我突然冒泡了)

如果我们想要一列表的1到20这些整数怎么办？我们显然可以直接把它们敲进去，但是显然的我们这些想要比较正常地编程的人不希望这么做。所以我们要用范围。我们可以用范围表示可枚举的东西构成歌的“等差数列”。数字可以枚举：1, 2, 3, 4...字符可以枚举，英文字母表就是从A到Z的枚举。人名不能枚举。“小明”下一个是什么？我怎么知道呢。

要造出一列表的1到20的自然数，你可以写`[1..20]`。它和`[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`是等效的，两者唯一的区别是手打那个特别长的奇葩很累，很无聊

    ghci> [1..20]  
    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]  
    ghci> ['a'..'z']  
    "abcdefghijklmnopqrstuvwxyz"  
    ghci> ['K'..'Z']  
    "KLMNOPQRSTUVWXYZ"   

范围里可以指定一个步长，（译者注：可以像数学课上那样指定！）如果我们想要所有1到20的偶数怎么办？或者要1到20里所有3的倍数怎么办？

    ghci> [2,4..20]  
    [2,4,6,8,10,12,14,16,18,20]  
    ghci> [3,6..20]  
    [3,6,9,12,15,18]   

只需要写出前两个元素和终止元素就行了。虽然范围比较智能，但还没有人们最终期望的那样智能。直接写`[1,2,4,8,16..100]`来得到2的幂是不行的。首先是你只能指定一个“步”，而且不是等差数列的话光给开头几个哪里够呢？

要弄一列表从20到1的数，你不能直接输入`[20..1]`，你得输入`[20,19..1]`。

注意以下在指定范围时用浮点数的一个问题。因为浮点数从来就没有精确过，所以如果你用在范围里可能会很奇葩。

    ghci> [0.1, 0.3 .. 1]  
    [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]  

那就别用好了。

你也可以用范围搞个无限列表，只要不写终止元素就行了。以后再多说点关于无限列表的事。我们先看看怎么得到13的前24个倍数。你当然可以用`[13,26..24*13]`，但是还有一个更好的方法：`take 24 [13,26..]`因为haskell是懒惰求值的，所以当你写下一个无限列表时它不会被求值，否则就根本停不下来了。它会先看看你想拿这个列表干什么，然后它发现你要前24个元素，然后就算出了24个元素就停了。

这是一些能产生无限长列表的函数：

`cycle`把一个列表无限接下去。你得把它截断再看它的值，要不它会一直输出，根本停不下来的。

    ghci> take 10 (cycle [1,2,3])  
    [1,2,3,1,2,3,1,2,3,1]  
    ghci> take 12 (cycle "LOL ")  
    "LOL LOL LOL "   

`repeat`把一个元素接无数次。你可以把它看成只有一个元素的`repeat`

    ghci> take 10 (repeat 5)  
    [5,5,5,5,5,5,5,5,5,5]  

当然如果你只是想要一列表的几个一样的元素你还可以用`replicate`。`replicate 3 10`的值是`[10,10,10]`。
