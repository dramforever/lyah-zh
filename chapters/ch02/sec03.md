## 2.3 列表

就像购物列表一样，Haskell中列表非常有用。它是最常用的数据结构，有许许多多不同的用途来建模和解决一大堆问题。列表特别有用，这里我们会看看列表、字符串（也是列表）和列表构造的一些基础知识。

Haskell里列表是一个**同质**的数据结构，也就是说列表里的元素必须是同一个类型的。这意味着我们可以写一列表的整数或一列表的字符，但是不能既有整数又有字符。我们先搞个列表出来

> 注：我们可以在GHCi里面使用`let`关键字来直接定义一个名称。在GHCi里面写`let a = 1`和在一个程序里写`a = 1`并把它载入是一样的。

    ghci> let lostNumbers = [4,8,15,16,23,42]  
    ghci> lostNumbers  
    [4,8,15,16,23,42]  

正如你见到的那样，列表是用方括号括起来的逗号分割的几个元素。如果我们写一个`[1,2,'a',3,'b','c',4]`，Haskell会表示字符（用单引号括起来表示）不是数。说到字符，`"hello"`其实就是`['h','e','l','l','o']`的简写。因为字符串是列表，我们也可以在字符串上方便地使用列表函数。

一个重要的列表操作是列表的连接。我们用`++`将两个列表连接。

    ghci> [1,2,3,4] ++ [9,10,11,12]  
    [1,2,3,4,9,10,11,12]  
    ghci> "hello" ++ " " ++ "world"  
    "hello world"  
    ghci> ['w','o'] ++ ['o','t']  
    "woot"  

注意以下重复使用`++`所产生的效果。当你把两个列表加起来的时候，（即使只是向一个列表里添加一个元素，比如是`[1,2,3] ++ [4]`）Haskell需要把`++`左边的列表完全走一遍。对于一个不太大的列表这可能不是问题，但你把一个东西加在一个五千万个元素的列表里可能会需要点时间！但是你可以使用`:`（也就是所谓的cons）来把一个元素加在一个列表前面。这个操作是非常快的。

    ghci> 'A':" SMALL CAT"  
    "A SMALL CAT"  
    ghci> 5:[1,2,3,4,5]  
    [5,1,2,3,4,5]  

（译者注：你可能已经发现了Haskell的列表其实就是链表。答对加十分！）

仔细看看，`:`接受一个数和一列数或者一个字符和一列字符，而`++`接受两个列表。即使你只是用`++`向一个列表里加一个元素你也得用方括号括起来让它变成一个列表。

`[1,2,3]`其实只是`1:2:3:[]`的简写。`[]`是空列表。如果我们在它前面加上`3`它就变成`[3]`，再加个`2`就变成`[2,3]`，以此类推。

> 注：`[]`、`[[]]`和`[[],[],[]]`是不同的。第一个是空列表，第二个是有一个空列表的列表，第三个是有三个空列表的列表。

如果你想要使用位置偏移量（译者注：index叫啥来着？）来获取列表元素，请使用`!!`运算符。偏移从0开始。

    ghci> "Steve Buscemi" !! 6  
    'B'  
    ghci> [9.4,33.2,96.2,11.2,23.25] !! 1  
    33.2  

但是如果你想取出只有4个元素的列表里的第6个元素会产生一个错误，所以还是小心为好。

（译者注：取第k个元素是O(k)不是O(1)哦～～）

列表也能包含列表，也能包含包含列表的列表～～

    ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
    ghci> b  
    [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
    ghci> b ++ [[1,1,1,1]]  
    [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]  
    ghci> [6,6,6]:b  
    [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
    ghci> b !! 2  
    [1,2,2,3,4]   

列表里的列表可以不一样长，但类型必须一样。就像你不能有一个既有字符又有数字的列表一样，你也不能有既有字符列表也有数字列表的列表。

如果列表包含的内容可以被比较，则列表可以被比较。当使用`<`, `<=`, `>`和`>=`比较列表时使用字典顺序。首先比较第一个，如果相等就比较第二个，一直这样下去。

    ghci> [3,2,1] > [2,1,0]  
    True  
    ghci> [3,2,1] > [2,10,100]  
    True  
    ghci> [3,4,2] > [3,4]  
    True  
    ghci> [3,4,2] > [2,4]  
    True  
    ghci> [3,4,2] == [3,4,2]  
    True  

列表还能用来干吗？下面是一些常用的列表函数

`head`返回一个列表的第一个

    ghci> head [5,4,3,2,1]  
    5   

`tail`返回一个列表去掉第一个

    ghci> tail [5,4,3,2,1]  
    [4,3,2,1]   

`last`返回一个列表的最后一个

    ghci> last [5,4,3,2,1]  
    1   

`init`返回一个列表去掉最后一个

    ghci> init [5,4,3,2,1]  
    [5,4,3,2]   

下面这个图可能可以帮你理解这些东西

![list monster](http://drops.illumer.org/usr/uploads/2014/05/2004517552.png)

如果我们想要一个空列表的第一个会怎么样？

    ghci> head []  
    *** Exception: Prelude.head: empty list  

尼玛，报错了～～如果列表里啥都没有没有，它肯定没有第一个。在使用`head`, `tail`, `last`和`init`时要小心不要传入一个空列表。在编译时这个错误是看不出来的，所以你最好还是检查一下，不要让Haskell从空列表里取东西。

`length`返回一个列表的长度。这是显然的

    ghci> length [5,4,3,2,1]  
    5  

`null`返回一个列表是否为空。它比`xs == []`快（假设你的列表叫`xs`）

    ghci> null [1,2,3]  
    False  
    ghci> null []  
    True  

`reverse`将一个列表反转

    ghci> reverse [5,4,3,2,1]  
    [1,2,3,4,5]  

`take`从一个列表开头截取一定量的元素

    ghci> take 3 [5,4,3,2,1]  
    [5,4,3]  
    ghci> take 1 [3,9,3]  
    [3]  
    ghci> take 5 [1,2]  
    [1,2]  
    ghci> take 0 [6,6,6]  
    []  

如果我们要的太多，`take`就会返回整个列表

`drop`很类似，它从一个列表开头切掉一定量的元素

    ghci> drop 3 [8,4,2,1,5,6]  
    [1,5,6]  
    ghci> drop 0 [1,2,3,4]  
    [1,2,3,4]  
    ghci> drop 100 [1,2,3,4]  
    []   

`maximum`返回一个包含可被比较元素的列表中最大的

`minimum`返回最小的

    ghci> minimum [8,4,2,1,5,6]  
    1  
    ghci> maximum [1,9,2,3,4]  
    9   

`sum`返回一列表数的和

`product`返回一列表数的积

    ghci> sum [5,2,1,6,3,2,5,7]  
    31  
    ghci> product [6,2,1,2]  
    24  
    ghci> product [1,2,5,6,7,9,2,0]  
    0   

`elem`返回一个元素是否在一个列表里。它一般以中缀形式调用，因为这样好看。

    ghci> 4 `elem` [3,4,5,6]  
    True  
    ghci> 10 `elem` [3,4,5,6]  
    False 
 
还有一些列表函数，我们以后再讲
